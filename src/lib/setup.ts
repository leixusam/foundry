/**
 * Shared setup module for Foundry configuration.
 * Used by both `foundry` (main loop) and `foundry config` commands.
 */

import {
  existsSync,
  mkdirSync,
  readFileSync,
  writeFileSync,
  appendFileSync,
  copyFileSync,
  readdirSync,
} from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { createInterface } from 'readline';
import { getRepoRoot } from '../config.js';
import {
  createLinearClient,
  validateApiKey,
  getTeamByKeyOrId,
  checkFoundryStatusesExist,
  ensureFoundryStatuses,
  FOUNDRY_STATUS_PREFIX,
} from './linear-api.js';
import { isClaudeCliInstalled, isCodexCliInstalled, hasAnyCli, CliAvailability } from './cli-detection.js';
import { ProviderName, ClaudeModel, CodexReasoningEffort, InitResult, MergeMode } from '../types.js';

// Get the package directory (where Foundry is installed)
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const PACKAGE_ROOT = join(__dirname, '../..');

// Team info for display
export interface TeamInfo {
  id: string;
  key: string;
  name: string;
}

// Loaded configuration from .foundry/env
export interface LoadedConfig {
  linearApiKey?: string;
  linearTeamKey?: string;
  provider?: ProviderName;
  claudeModel?: ClaudeModel;
  codexModel?: string;
  codexReasoningEffort?: CodexReasoningEffort;
  maxIterations?: number;
  mergeMode?: MergeMode;
}

// MCP configuration interface
interface McpConfig {
  mcpServers: {
    [key: string]: {
      type: string;
      url: string;
      headers: {
        [key: string]: string;
      };
    };
  };
}

// ════════════════════════════════════════════════════════════════════════════
// Directory Setup
// ════════════════════════════════════════════════════════════════════════════

/**
 * Ensures .foundry/ directory exists.
 * Returns the path to the directory.
 */
export function ensureFoundryDir(): string {
  const foundryDir = join(getRepoRoot(), '.foundry');
  if (!existsSync(foundryDir)) {
    mkdirSync(foundryDir, { recursive: true });
  }
  return foundryDir;
}

/**
 * Ensures foundry-docs/ directory exists with README.
 */
export function ensureFoundryDocsDir(): void {
  const docsDir = join(getRepoRoot(), 'foundry-docs');
  if (!existsSync(docsDir)) {
    mkdirSync(docsDir, { recursive: true });
  }

  // Create README if it doesn't exist
  const readmePath = join(docsDir, 'README.md');
  if (!existsSync(readmePath)) {
    const readme = `# Foundry Documentation

This directory contains documentation automatically generated by [Foundry](https://www.npmjs.com/package/@leixusam/foundry), an autonomous product development system.

## Contents

- \`research/\` - Research documents for tickets
- \`plans/\` - Implementation plans
- \`specifications/\` - Technical specifications
- \`validation/\` - Validation reports
- \`oneshot/\` - Quick implementation notes
- \`shared/\` - Shared context between sessions

## Note for Developers

These files are **intended to be committed** to version control. They provide context and history for AI-assisted development work.

While the content is AI-generated, it documents real decisions, research, and implementation details that are valuable for understanding the codebase evolution.

Learn more: https://www.npmjs.com/package/@leixusam/foundry
`;
    writeFileSync(readmePath, readme);
  }
}

/**
 * Ensures .foundry/ is in .gitignore.
 */
export function ensureGitignore(): void {
  const gitignorePath = join(getRepoRoot(), '.gitignore');
  const entry = '.foundry/';

  let content = '';
  if (existsSync(gitignorePath)) {
    content = readFileSync(gitignorePath, 'utf-8');
  }

  // Check if already ignored
  const lines = content.split('\n');
  const alreadyIgnored = lines.some(
    (line) => line.trim() === entry || line.trim() === '.foundry'
  );

  if (alreadyIgnored) {
    return;
  }

  // Append to .gitignore
  const newContent = content.endsWith('\n') || content === ''
    ? content + `# Foundry runtime data\n${entry}\n`
    : content + `\n# Foundry runtime data\n${entry}\n`;

  writeFileSync(gitignorePath, newContent, 'utf-8');
}

// ════════════════════════════════════════════════════════════════════════════
// Config Loading/Saving
// ════════════════════════════════════════════════════════════════════════════

/**
 * Loads existing configuration from .foundry/env file.
 */
export function loadExistingConfig(): LoadedConfig {
  const envPath = join(getRepoRoot(), '.foundry', 'env');

  if (!existsSync(envPath)) {
    return {};
  }

  const content = readFileSync(envPath, 'utf-8');

  const getValue = (key: string): string | undefined => {
    const match = content.match(new RegExp(`^${key}=(.+)$`, 'm'));
    return match ? match[1].trim() : undefined;
  };

  const config: LoadedConfig = {};

  const apiKey = getValue('LINEAR_API_KEY');
  if (apiKey) config.linearApiKey = apiKey;

  const teamKey = getValue('LINEAR_TEAM_KEY');
  if (teamKey) config.linearTeamKey = teamKey;

  const provider = getValue('FOUNDRY_PROVIDER');
  if (provider === 'claude' || provider === 'codex') {
    config.provider = provider;
  }

  const claudeModel = getValue('FOUNDRY_CLAUDE_MODEL');
  if (claudeModel === 'opus' || claudeModel === 'sonnet' || claudeModel === 'haiku') {
    config.claudeModel = claudeModel;
  }

  const codexModel = getValue('CODEX_MODEL');
  if (codexModel) config.codexModel = codexModel;

  const codexEffort = getValue('CODEX_REASONING_EFFORT');
  if (codexEffort === 'low' || codexEffort === 'medium' || codexEffort === 'high' || codexEffort === 'extra_high') {
    config.codexReasoningEffort = codexEffort;
  }

  const maxIterations = getValue('FOUNDRY_MAX_ITERATIONS');
  if (maxIterations !== undefined) {
    const parsed = parseInt(maxIterations, 10);
    if (!isNaN(parsed)) config.maxIterations = parsed;
  }

  const mergeMode = getValue('FOUNDRY_MERGE_MODE');
  if (mergeMode === 'auto' || mergeMode === 'merge' || mergeMode === 'pr') {
    config.mergeMode = mergeMode;
  }

  return config;
}

/**
 * Saves configuration to .foundry/env file.
 */
export function saveEnvConfig(config: LoadedConfig): void {
  const envPath = join(ensureFoundryDir(), 'env');

  const lines: string[] = [
    '# Foundry Configuration',
    '# Generated by foundry config',
    '',
    '# Linear (required)',
  ];

  if (config.linearApiKey) {
    lines.push(`LINEAR_API_KEY=${config.linearApiKey}`);
  }
  if (config.linearTeamKey) {
    lines.push(`LINEAR_TEAM_KEY=${config.linearTeamKey}`);
  }

  lines.push('');
  lines.push('# Provider: "claude" or "codex"');
  lines.push(`FOUNDRY_PROVIDER=${config.provider || 'claude'}`);

  lines.push('');
  lines.push('# Claude options');
  lines.push(`FOUNDRY_CLAUDE_MODEL=${config.claudeModel || 'opus'}`);

  lines.push('');
  lines.push('# Codex options');
  lines.push(`CODEX_MODEL=${config.codexModel || 'gpt-5.3-codex'}`);
  lines.push(`CODEX_REASONING_EFFORT=${config.codexReasoningEffort || 'high'}`);

  lines.push('');
  lines.push('# Loop options (0 = unlimited)');
  lines.push(`FOUNDRY_MAX_ITERATIONS=${config.maxIterations ?? 0}`);

  lines.push('');
  lines.push('# Merge mode: "auto" (agent decides), "merge" (direct to main), or "pr" (create pull request)');
  lines.push(`FOUNDRY_MERGE_MODE=${config.mergeMode || 'auto'}`);

  lines.push(''); // Trailing newline

  writeFileSync(envPath, lines.join('\n'), 'utf-8');
}

/**
 * Saves MCP configuration with Linear API key.
 */
export function saveMcpConfig(apiKey: string): void {
  const mcpPath = join(ensureFoundryDir(), 'mcp.json');

  let config: McpConfig = { mcpServers: {} };

  // Read existing config if it exists
  if (existsSync(mcpPath)) {
    try {
      const existing = readFileSync(mcpPath, 'utf-8');
      config = JSON.parse(existing);
      if (!config.mcpServers) {
        config.mcpServers = {};
      }
    } catch {
      config = { mcpServers: {} };
    }
  }

  // Add or update Linear MCP server
  config.mcpServers.linear = {
    type: 'http',
    url: 'https://mcp.linear.app/mcp',
    headers: {
      Authorization: `Bearer ${apiKey}`,
    },
  };

  writeFileSync(mcpPath, JSON.stringify(config, null, 2) + '\n', 'utf-8');
}

/**
 * Saves Codex MCP configuration to global ~/.codex/config.toml.
 * Uses bearer_token_env_var so the actual API key stays in .foundry/env.
 */
export function saveCodexMcpConfig(): void {
  const homeDir = process.env.HOME || process.env.USERPROFILE || '';
  const codexDir = join(homeDir, '.codex');
  const configPath = join(codexDir, 'config.toml');

  // Ensure ~/.codex directory exists
  if (!existsSync(codexDir)) {
    mkdirSync(codexDir, { recursive: true });
  }

  // Read existing config if it exists
  let existingContent = '';
  if (existsSync(configPath)) {
    existingContent = readFileSync(configPath, 'utf-8');
  }

  // Check if [mcp_servers.linear] section already exists
  if (existingContent.includes('[mcp_servers.linear]')) {
    // Update the existing section - find and replace
    const linearSectionRegex = /\[mcp_servers\.linear\][^\[]*(?=\[|$)/s;
    const newSection = `[mcp_servers.linear]
url = "https://mcp.linear.app/mcp"
bearer_token_env_var = "LINEAR_API_KEY"

`;
    existingContent = existingContent.replace(linearSectionRegex, newSection);
  } else {
    // Append the new section
    const newSection = `
[mcp_servers.linear]
url = "https://mcp.linear.app/mcp"
bearer_token_env_var = "LINEAR_API_KEY"
`;
    existingContent = existingContent.trimEnd() + '\n' + newSection;
  }

  writeFileSync(configPath, existingContent, 'utf-8');
}

// ════════════════════════════════════════════════════════════════════════════
// CLI Detection
// ════════════════════════════════════════════════════════════════════════════

/**
 * Checks which CLIs are available and displays results one-by-one.
 * Provides real-time feedback as each check completes.
 * Returns availability, or undefined if neither is installed.
 */
export function checkAndDisplayCliAvailability(): CliAvailability | undefined {
  console.log('Detecting CLIs...');

  // Check Claude Code first, display immediately
  process.stdout.write('  Claude Code: checking...');
  const claudeAvailable = isClaudeCliInstalled();
  const claudeStatus = claudeAvailable ? '✓ installed' : '✗ not found';
  process.stdout.write(`\r  Claude Code: ${claudeStatus}   \n`);

  // Check Codex, display immediately
  process.stdout.write('  Codex CLI:   checking...');
  const codexAvailable = isCodexCliInstalled();
  const codexStatus = codexAvailable ? '✓ installed' : '✗ not found';
  process.stdout.write(`\r  Codex CLI:   ${codexStatus}   \n`);

  console.log('');

  const availability: CliAvailability = {
    claude: claudeAvailable,
    codex: codexAvailable,
  };

  if (!hasAnyCli(availability)) {
    console.log('❌ Error: No coding CLI found');
    console.log('');
    console.log('   Foundry requires at least one of the following:');
    console.log('');
    console.log('   Claude Code CLI:');
    console.log('     npm install -g @anthropic-ai/claude-code');
    console.log('');
    console.log('   Codex CLI:');
    console.log('     npm install -g @openai/codex');
    console.log('');
    return undefined;
  }

  return availability;
}

/**
 * Auto-selects provider based on CLI availability.
 * Prefers Claude if both are available.
 */
export function autoSelectProvider(availability: CliAvailability): ProviderName {
  if (availability.claude) return 'claude';
  return 'codex';
}

// ════════════════════════════════════════════════════════════════════════════
// Linear Setup
// ════════════════════════════════════════════════════════════════════════════

/**
 * Validates a Linear API key.
 */
export async function validateLinearKey(apiKey: string): Promise<boolean> {
  const client = createLinearClient(apiKey);
  return await validateApiKey(client);
}

/**
 * Fetches available teams from Linear.
 */
export async function fetchLinearTeams(apiKey: string): Promise<TeamInfo[]> {
  const client = createLinearClient(apiKey);
  const teamsResult = await client.teams();
  return teamsResult.nodes.map((t) => ({
    id: t.id,
    key: t.key,
    name: t.name,
  }));
}

/**
 * Checks if Linear ∞ statuses exist.
 */
export async function checkLinearStatuses(apiKey: string, teamKey: string): Promise<boolean> {
  const client = createLinearClient(apiKey);
  const team = await getTeamByKeyOrId(client, teamKey);
  if (!team) return false;
  return await checkFoundryStatusesExist(client, team.id);
}

/**
 * Creates Linear ∞ statuses.
 * Returns result with created/existing/errors counts.
 */
export async function createLinearStatuses(apiKey: string, teamKey: string): Promise<InitResult> {
  const client = createLinearClient(apiKey);
  const team = await getTeamByKeyOrId(client, teamKey);

  if (!team) {
    return {
      success: false,
      created: [],
      existing: [],
      errors: [`Team "${teamKey}" not found`],
    };
  }

  return await ensureFoundryStatuses(client, team.id);
}

// ════════════════════════════════════════════════════════════════════════════
// File Operations
// ════════════════════════════════════════════════════════════════════════════

/**
 * Copies prompts from package to .foundry/prompts/.
 * Assembles prompts with merge fragment based on current config.
 */
export function copyPromptsToProject(): void {
  const sourceDir = join(PACKAGE_ROOT, 'prompts');
  const fragmentsDir = join(sourceDir, 'fragments');
  const destDir = join(ensureFoundryDir(), 'prompts');

  if (!existsSync(destDir)) {
    mkdirSync(destDir, { recursive: true });
  }

  if (!existsSync(sourceDir)) {
    console.log('Warning: Prompts directory not found in package.');
    return;
  }

  // Load current config to determine merge mode
  const config = loadExistingConfig();
  const mergeMode = config.mergeMode || 'auto';
  const provider = config.provider || 'claude';

  // Load the appropriate merge fragment
  const fragmentName = mergeMode === 'auto'
    ? 'merge-auto.md'
    : mergeMode === 'pr'
      ? 'merge-pr.md'
      : 'merge-direct.md';
  const fragmentPath = join(fragmentsDir, fragmentName);
  let mergeFragment = '';
  if (existsSync(fragmentPath)) {
    mergeFragment = readFileSync(fragmentPath, 'utf-8');

    // Substitute provider link in fragment
    const providerLink = provider === 'codex'
      ? '[Codex](https://openai.com/codex)'
      : '[Claude Code](https://claude.ai/claude-code)';
    mergeFragment = mergeFragment.replace(/\{\{PROVIDER_LINK\}\}/g, providerLink);
  }

  const files = readdirSync(sourceDir).filter((f) => f.endsWith('.md'));
  let copied = 0;

  for (const file of files) {
    let content = readFileSync(join(sourceDir, file), 'utf-8');

    // For worker prompts, substitute merge instructions and stage-specific placeholders
    if (file === 'agent2-worker-oneshot.md') {
      content = content.replace('{{MERGE_INSTRUCTIONS}}',
        mergeFragment
          .replace(/\{\{STAGE\}\}/g, 'oneshot')
          .replace(/\{\{WORKFLOW\}\}/g, 'oneshot')
          .replace(/\{\{ARTIFACT_DIR\}\}/g, 'oneshot')
      );
    } else if (file === 'agent2-worker-validate.md') {
      content = content.replace('{{MERGE_INSTRUCTIONS}}',
        mergeFragment
          .replace(/\{\{STAGE\}\}/g, 'validate')
          .replace(/\{\{WORKFLOW\}\}/g, 'staged')
          .replace(/\{\{ARTIFACT_DIR\}\}/g, 'validation')
      );
    }

    writeFileSync(join(destDir, file), content);
    copied++;
  }

  console.log(`   Prompts synced (${copied} files, merge mode: ${mergeMode})`);
}

// ════════════════════════════════════════════════════════════════════════════
// Prompt Helpers
// ════════════════════════════════════════════════════════════════════════════

/**
 * Creates a readline interface for prompting.
 */
export function createPromptInterface(): ReturnType<typeof createInterface> {
  return createInterface({ input: process.stdin, output: process.stdout });
}

/**
 * Prompts for input with optional default value.
 */
export async function promptWithDefault(
  rl: ReturnType<typeof createInterface>,
  question: string,
  defaultValue?: string
): Promise<string> {
  return new Promise((resolve) => {
    const displayDefault = defaultValue ? ` [${defaultValue}]` : '';
    rl.question(`${question}${displayDefault}: `, (answer) => {
      resolve(answer.trim() || defaultValue || '');
    });
  });
}

/**
 * Prompts for a secret value (doesn't show default).
 */
export async function promptSecret(
  rl: ReturnType<typeof createInterface>,
  question: string
): Promise<string> {
  return new Promise((resolve) => {
    rl.question(`${question}: `, (answer) => {
      resolve(answer.trim());
    });
  });
}

/**
 * Prompts for yes/no confirmation.
 */
export async function promptConfirm(
  rl: ReturnType<typeof createInterface>,
  question: string,
  defaultYes = true
): Promise<boolean> {
  return new Promise((resolve) => {
    const hint = defaultYes ? '[Y/n]' : '[y/N]';
    rl.question(`${question} ${hint}: `, (answer) => {
      const trimmed = answer.trim().toLowerCase();
      if (trimmed === '') {
        resolve(defaultYes);
      } else {
        resolve(trimmed === 'y' || trimmed === 'yes');
      }
    });
  });
}

/**
 * Option for numbered selection prompts.
 */
export interface SelectOption<T> {
  value: T;
  label: string;
  description?: string;
}

/**
 * Prompts user to select from a numbered list.
 * Shows options as numbered list and accepts number input.
 * Returns the selected option's value.
 */
export async function promptSelect<T>(
  rl: ReturnType<typeof createInterface>,
  options: SelectOption<T>[],
  defaultIndex = 0
): Promise<T> {
  return new Promise((resolve) => {
    // Display numbered options
    options.forEach((opt, i) => {
      const desc = opt.description ? ` - ${opt.description}` : '';
      console.log(`  ${i + 1}. ${opt.label}${desc}`);
    });
    console.log('');

    rl.question(`Choice [default=${defaultIndex + 1}]: `, (answer) => {
      const trimmed = answer.trim();

      // Empty input = use default
      if (trimmed === '') {
        resolve(options[defaultIndex].value);
        return;
      }

      // Parse number
      const num = parseInt(trimmed, 10);
      if (!isNaN(num) && num >= 1 && num <= options.length) {
        resolve(options[num - 1].value);
        return;
      }

      // Invalid input, use default
      console.log(`Invalid choice, using default (${defaultIndex + 1})`);
      resolve(options[defaultIndex].value);
    });
  });
}

/**
 * Masks an API key for display (shows last 4 chars).
 */
export function maskApiKey(apiKey: string): string {
  if (apiKey.length <= 4) return '****';
  return '****' + apiKey.slice(-4);
}

// ════════════════════════════════════════════════════════════════════════════
// Codex MCP Check
// ════════════════════════════════════════════════════════════════════════════

export { checkCodexLinearMcpConfigured as checkCodexLinearMcp } from './codex.js';

// Re-export for convenience
export { FOUNDRY_STATUS_PREFIX } from './linear-api.js';
export { CliAvailability } from './cli-detection.js';
