import {
  existsSync,
  mkdirSync,
  copyFileSync,
  readdirSync,
  appendFileSync,
  readFileSync,
  writeFileSync,
  rmSync,
} from 'fs';
import { execSync } from 'child_process';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';
import { createInterface } from 'readline';
import { getRepoRoot } from '../config.js';
import {
  createLinearClient,
  validateApiKey,
  getTeamByKeyOrId,
  deleteFoundryStatuses,
  FOUNDRY_STATUS_PREFIX,
} from './linear-api.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Check if a CLI tool is installed
function isInstalled(command: string): boolean {
  try {
    execSync(`which ${command}`, { stdio: 'pipe' });
    return true;
  } catch {
    return false;
  }
}

// Prompt helper with default value
async function promptWithDefault(
  rl: ReturnType<typeof createInterface>,
  question: string,
  defaultValue: string,
): Promise<string> {
  return new Promise((resolve) => {
    const displayDefault = defaultValue ? ` [${defaultValue}]` : '';
    rl.question(`${question}${displayDefault}: `, (answer) => {
      resolve(answer.trim() || defaultValue);
    });
  });
}

// Prompt for secret (no default shown)
async function promptSecret(
  rl: ReturnType<typeof createInterface>,
  question: string,
): Promise<string> {
  return new Promise((resolve) => {
    rl.question(`${question}: `, (answer) => {
      resolve(answer.trim());
    });
  });
}

export async function initProject(): Promise<void> {
  const projectRoot = getRepoRoot();

  console.log('');
  console.log('╔════════════════════════════════════════╗');
  console.log('║     Foundry - Setup Wizard             ║');
  console.log('╚════════════════════════════════════════╝');
  console.log('');
  console.log(`Initializing in: ${projectRoot}`);
  console.log('');

  // 1. Check installed providers
  const claudeInstalled = isInstalled('claude');
  const codexInstalled = isInstalled('codex');

  console.log('Detected providers:');
  console.log(`  Claude Code: ${claudeInstalled ? '✓ installed' : '✗ not found'}`);
  console.log(`  Codex CLI:   ${codexInstalled ? '✓ installed' : '✗ not found'}`);
  console.log('');

  if (!claudeInstalled && !codexInstalled) {
    console.error('Error: No LLM provider found. Install Claude Code or Codex CLI first.');
    console.error('  Claude Code: npm install -g @anthropic-ai/claude-code');
    console.error('  Codex CLI:   See https://github.com/openai/codex');
    process.exit(1);
  }

  // 2. Create .foundry/ directory
  const foundryDir = join(projectRoot, '.foundry');
  if (!existsSync(foundryDir)) {
    mkdirSync(foundryDir, { recursive: true });
  }

  // 3. Load existing config if present
  const envPath = join(foundryDir, 'env');
  const existingEnv = existsSync(envPath) ? readFileSync(envPath, 'utf-8') : '';

  const getExisting = (key: string): string => {
    const match = existingEnv.match(new RegExp(`${key}=(.+)`));
    return match ? match[1] : '';
  };

  // 4. Interactive setup
  const rl = createInterface({ input: process.stdin, output: process.stdout });

  // Linear credentials
  console.log('─── Linear Configuration ───');
  console.log('Get your API key from: https://linear.app/settings/api');
  console.log('');

  let linearApiKey: string;
  if (getExisting('LINEAR_API_KEY')) {
    console.log('LINEAR_API_KEY: (already configured)');
    linearApiKey = getExisting('LINEAR_API_KEY');
  } else {
    linearApiKey = await promptSecret(rl, 'LINEAR_API_KEY');
  }

  let linearTeamKey: string;
  if (getExisting('LINEAR_TEAM_KEY')) {
    console.log('LINEAR_TEAM_KEY: (already configured)');
    linearTeamKey = getExisting('LINEAR_TEAM_KEY');
  } else {
    linearTeamKey = await promptWithDefault(rl, 'LINEAR_TEAM_KEY (e.g., RSK)', '');
  }

  console.log('');

  // Provider selection
  console.log('─── Provider Configuration ───');
  const defaultProvider = claudeInstalled ? 'claude' : 'codex';
  const provider = await promptWithDefault(rl, 'Provider (claude/codex)', defaultProvider);

  let claudeModel = 'opus';
  let codexModel = 'gpt-5.2';
  let codexEffort = 'high';

  if (provider === 'claude') {
    claudeModel = await promptWithDefault(rl, 'Claude model (opus/sonnet/haiku)', 'opus');
  } else {
    codexModel = await promptWithDefault(rl, 'Codex model', 'gpt-5.2');
    codexEffort = await promptWithDefault(rl, 'Reasoning effort (low/medium/high/extra_high)', 'high');
  }

  console.log('');

  // Iteration limit
  console.log('─── Loop Configuration ───');
  const maxIterations = await promptWithDefault(rl, 'Max iterations (0 = unlimited)', '0');

  rl.close();

  // 5. Save configuration
  const envContent = `# Foundry Configuration
# Generated by foundry init

# Linear (required)
LINEAR_API_KEY=${linearApiKey}
LINEAR_TEAM_KEY=${linearTeamKey}

# Provider: "claude" or "codex"
FOUNDRY_PROVIDER=${provider}

# Claude options
FOUNDRY_CLAUDE_MODEL=${claudeModel}

# Codex options
CODEX_MODEL=${codexModel}
CODEX_REASONING_EFFORT=${codexEffort}

# Loop options (0 = unlimited)
FOUNDRY_MAX_ITERATIONS=${maxIterations}
`;

  writeFileSync(envPath, envContent);
  console.log('');
  console.log('Saved configuration to .foundry/env');

  // 6. Configure MCP for Linear (Claude Code needs this)
  const mcpPath = join(foundryDir, 'mcp.json');
  const mcpConfig = {
    mcpServers: {
      linear: {
        type: 'http',
        url: 'https://mcp.linear.app/mcp',
        headers: {
          Authorization: `Bearer ${linearApiKey}`,
        },
      },
    },
  };
  writeFileSync(mcpPath, JSON.stringify(mcpConfig, null, 2) + '\n');
  console.log('Configured Linear MCP in .foundry/mcp.json');

  // 7. Add .foundry/ to .gitignore
  const gitignorePath = join(projectRoot, '.gitignore');
  const gitignoreEntry = '.foundry/';

  if (existsSync(gitignorePath)) {
    const content = readFileSync(gitignorePath, 'utf-8');
    if (!content.includes(gitignoreEntry)) {
      appendFileSync(gitignorePath, `\n# Foundry runtime data\n${gitignoreEntry}\n`);
      console.log('Added .foundry/ to .gitignore');
    }
  } else {
    writeFileSync(gitignorePath, `# Foundry runtime data\n${gitignoreEntry}\n`);
    console.log('Created .gitignore with .foundry/');
  }

  // 8. Copy Claude Code commands
  // When installed via npm: __dirname is node_modules/@leixusam/foundry/dist/lib
  // commands are at: node_modules/@leixusam/foundry/.claude/commands
  const sourceCommandsDir = join(__dirname, '../../.claude/commands');
  const targetCommandsDir = join(projectRoot, '.claude', 'commands');

  if (existsSync(sourceCommandsDir)) {
    if (!existsSync(targetCommandsDir)) {
      mkdirSync(targetCommandsDir, { recursive: true });
    }

    const files = readdirSync(sourceCommandsDir).filter((f) => f.endsWith('.md'));
    for (const file of files) {
      copyFileSync(join(sourceCommandsDir, file), join(targetCommandsDir, file));
    }
    if (files.length > 0) {
      console.log(`Installed ${files.length} Claude Code command(s) to .claude/commands/`);
    }
  }

  // 9. Create foundry-docs/ directory with README
  const docsDir = join(projectRoot, 'foundry-docs');
  if (!existsSync(docsDir)) {
    mkdirSync(docsDir, { recursive: true });
    console.log('Created foundry-docs/ directory');
  }

  // Create README in foundry-docs/ if it doesn't exist
  const docsReadmePath = join(docsDir, 'README.md');
  if (!existsSync(docsReadmePath)) {
    const docsReadme = `# Foundry Documentation

This directory contains documentation automatically generated by [Foundry](https://www.npmjs.com/package/@leixusam/foundry), an autonomous product development system.

## Contents

- \`research/\` - Research documents for tickets
- \`plans/\` - Implementation plans
- \`specifications/\` - Technical specifications
- \`validation/\` - Validation reports
- \`oneshot/\` - Quick implementation notes
- \`shared/\` - Shared context between sessions

## Note for Developers

These files are **intended to be committed** to version control. They provide context and history for AI-assisted development work.

While the content is AI-generated, it documents real decisions, research, and implementation details that are valuable for understanding the codebase evolution.

Learn more: https://www.npmjs.com/package/@leixusam/foundry
`;
    writeFileSync(docsReadmePath, docsReadme);
  }

  console.log('');
  console.log('╔════════════════════════════════════════╗');
  console.log('║  ✓ Foundry initialized!                ║');
  console.log('║                                        ║');
  console.log('║  Next steps:                           ║');
  console.log('║  1. Run `foundry` to start the loop    ║');
  console.log('║  2. Or open Claude Code in this dir    ║');
  console.log('╚════════════════════════════════════════╝');
}

// Prompt for yes/no confirmation
async function promptConfirm(
  rl: ReturnType<typeof createInterface>,
  question: string,
): Promise<boolean> {
  return new Promise((resolve) => {
    rl.question(`${question} (y/n): `, (answer) => {
      resolve(answer.trim().toLowerCase() === 'y' || answer.trim().toLowerCase() === 'yes');
    });
  });
}

// Remove .foundry/ entry from .gitignore
function removeFromGitignore(projectRoot: string): boolean {
  const gitignorePath = join(projectRoot, '.gitignore');

  if (!existsSync(gitignorePath)) {
    return false;
  }

  const content = readFileSync(gitignorePath, 'utf-8');
  const lines = content.split('\n');

  // Filter out .foundry/ related lines
  const filteredLines = lines.filter((line) => {
    const trimmed = line.trim();
    return trimmed !== '.foundry/' && trimmed !== '.foundry' && trimmed !== '# Foundry runtime data';
  });

  // Only write if we actually removed something
  if (filteredLines.length < lines.length) {
    // Clean up any double newlines that might result
    const newContent = filteredLines.join('\n').replace(/\n{3,}/g, '\n\n');
    writeFileSync(gitignorePath, newContent);
    return true;
  }

  return false;
}

export async function uninstallProject(): Promise<void> {
  const projectRoot = getRepoRoot();
  const foundryDir = join(projectRoot, '.foundry');

  console.log('');
  console.log('╔════════════════════════════════════════╗');
  console.log('║     Foundry - Uninstall Wizard         ║');
  console.log('╚════════════════════════════════════════╝');
  console.log('');
  console.log(`Project: ${projectRoot}`);
  console.log('');

  // Check if Foundry is even installed
  if (!existsSync(foundryDir)) {
    console.log('Foundry is not installed in this project.');
    console.log('(No .foundry/ directory found)');
    process.exit(0);
  }

  // Show what will be removed
  console.log('This will remove:');
  console.log('');
  console.log('  1. .foundry/ directory containing:');
  console.log('     - env (Linear API key and configuration)');
  console.log('     - mcp.json (MCP configuration)');
  console.log('     - prompts/ (agent prompts)');
  console.log('     - output/ (run logs and session data)');
  console.log('');
  console.log('  2. .foundry/ entry from .gitignore');
  console.log('');

  // Load existing config to check for Linear credentials
  const envPath = join(foundryDir, 'env');
  let linearApiKey: string | undefined;
  let linearTeamKey: string | undefined;

  if (existsSync(envPath)) {
    const envContent = readFileSync(envPath, 'utf-8');
    const apiKeyMatch = envContent.match(/LINEAR_API_KEY=(.+)/);
    const teamKeyMatch = envContent.match(/LINEAR_TEAM_KEY=(.+)/);
    linearApiKey = apiKeyMatch?.[1];
    linearTeamKey = teamKeyMatch?.[1];
  }

  const hasLinearConfig = linearApiKey && linearTeamKey;

  if (hasLinearConfig) {
    console.log(`  3. Optionally: ${FOUNDRY_STATUS_PREFIX} workflow statuses from Linear`);
    console.log('     (Only empty statuses can be deleted)');
    console.log('');
  }

  console.log('─────────────────────────────────────────');
  console.log('');

  const rl = createInterface({ input: process.stdin, output: process.stdout });

  // Confirm uninstall
  const confirmUninstall = await promptConfirm(rl, 'Proceed with uninstall?');

  if (!confirmUninstall) {
    console.log('');
    console.log('Uninstall cancelled.');
    rl.close();
    process.exit(0);
  }

  console.log('');

  // Ask about Linear statuses if configured
  let deleteStatuses = false;
  if (hasLinearConfig) {
    deleteStatuses = await promptConfirm(
      rl,
      `Delete ${FOUNDRY_STATUS_PREFIX} workflow statuses from Linear?`
    );
  }

  rl.close();
  console.log('');

  // Step 1: Delete Linear statuses (before we lose the API key!)
  if (deleteStatuses && linearApiKey && linearTeamKey) {
    console.log('Removing Linear workflow statuses...');

    try {
      const client = createLinearClient(linearApiKey);

      // Validate API key still works
      const isValid = await validateApiKey(client);
      if (!isValid) {
        console.log('  Warning: Linear API key is invalid. Skipping status deletion.');
      } else {
        // Get team
        const team = await getTeamByKeyOrId(client, linearTeamKey);
        if (!team) {
          console.log(`  Warning: Team "${linearTeamKey}" not found. Skipping status deletion.`);
        } else {
          const result = await deleteFoundryStatuses(client, team.id);

          // Report results
          if (result.deleted.length > 0) {
            console.log(`  Deleted ${result.deleted.length} status(es):`);
            for (const name of result.deleted) {
              console.log(`    ✓ ${name}`);
            }
          }

          if (result.skipped.length > 0) {
            console.log('');
            console.log(`  Skipped ${result.skipped.length} status(es) with active issues:`);
            for (const { name, issueCount } of result.skipped) {
              console.log(`    ⚠ ${name} (${issueCount} issue${issueCount > 1 ? 's' : ''})`);
            }
            console.log('');
            console.log('  To delete these statuses manually:');
            console.log('    1. Move issues to other statuses in Linear');
            console.log('    2. Go to Settings → Teams → Workflow');
            console.log(`    3. Delete the ${FOUNDRY_STATUS_PREFIX} statuses`);
          }

          if (result.errors.length > 0) {
            console.log('');
            console.log(`  Errors (${result.errors.length}):`);
            for (const error of result.errors) {
              console.log(`    ✗ ${error}`);
            }
          }
        }
      }
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      console.log(`  Error connecting to Linear: ${msg}`);
    }

    console.log('');
  }

  // Step 2: Remove .foundry/ directory
  console.log('Removing .foundry/ directory...');
  try {
    rmSync(foundryDir, { recursive: true, force: true });
    console.log('  ✓ Removed .foundry/');
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    console.log(`  ✗ Error removing .foundry/: ${msg}`);
  }

  // Step 3: Clean up .gitignore
  console.log('Cleaning up .gitignore...');
  const removedFromGitignore = removeFromGitignore(projectRoot);
  if (removedFromGitignore) {
    console.log('  ✓ Removed .foundry/ from .gitignore');
  } else {
    console.log('  (No changes needed)');
  }

  console.log('');
  console.log('╔════════════════════════════════════════╗');
  console.log('║  ✓ Foundry uninstalled                 ║');
  console.log('╚════════════════════════════════════════╝');
}
